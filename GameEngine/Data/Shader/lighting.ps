#define LIT_MATERIAL_COUNT 128
#define UNLIT_MATERIAL_COUNT 
#define MAX_DIRECTIONAL_LIGHT_COUNT 4
#define MAX_POINT_LIGHT_COUNT 128
#define MAX_SPOT_LIGHT_COUNT 128

in vec2 texCoord;

#ifdef FORWARD
in vec3 position;
in vec3 normal;
in vec3 tangent;
in vec3 bitangent;
#endif

layout(location = 0) out vec4 finalColor;
layout(location = 1) out vec4 finalEmissive;

struct LitMaterialData
{
    vec3 diffuseColor;
    vec3 specularColor;
    vec3 emissiveColor;
    float shininess;
};

struct UnlitMaterialData
{
    vec3 diffuseColor;
};

layout(std140, binding = 1) uniform MaterialDataBlock
{
    LitMaterialData litMaterialData[ LIT_MATERIAL_COUNT ];
    UnlitMaterialData unlitMaterialData[ UNLIT_MATERIAL_COUNT ];
};

struct DirectionalLightData
{
	vec3 direction;
    float intensity;
	vec3 color;
    float bias;
    mat4 shadowViewProjection[ 4 ];
    vec4 shadowRange; // float shadowRange[ 4 ] would take 64 bytes in std140
};

struct PointLightData
{
	vec3 position;
	vec3 color;
	float intensity;
	float falloffMinDistance;
	float falloffMaxDistance;
};

struct SpotLightData
{
	vec3 position;
	vec3 direction;
	vec3 color;
	float intensity;
	float innerRange;
	float outerRange;
	float falloffMinDistance;
	float falloffMaxDistance;
};

layout(std140, binding = 2) uniform LightingDataBlock
{
	DirectionalLightData directionalLightData[ MAX_DIRECTIONAL_LIGHT_COUNT ];
	PointLightData pointLightData[ MAX_POINT_LIGHT_COUNT ];
	SpotLightData spotLightData[ MAX_SPOT_LIGHT_COUNT ];
	uint directionalLightCount;
	uint pointLightCount;
	uint spotLightCount;
};

uniform sampler2D diffuseMap;
uniform sampler2D normalMap;
uniform sampler2D specularMap;
uniform sampler2D emissiveMap;

uniform vec3 viewPosition;

#ifdef FORWARD
uniform uint materialID;
#else
uniform usampler2D materialMap;
uniform sampler2D depthMap;
uniform mat4 inverseViewProjection;
#endif

uniform sampler2DArrayShadow shadowMap;

void main()
{
    vec4 diffuseTextureColor = texture( diffuseMap, texCoord );

#ifdef FORWARD
    if( diffuseTextureColor.a < 0.001 )
        discard;

    mat3 TBN = mat3( normalize( tangent ), normalize( bitangent ), normalize( normal ) );

    vec3 tangentSpaceNormal = 2.0 * texture( normalMap, texCoord ).rgb - vec3( 1.0 );
    vec3 worldSpaceNormal = normalize( TBN * tangentSpaceNormal );
#else
    uint materialID = texture( materialMap, texCoord ).r;

    vec4 worldSpacePosition = vec4( 2.0 * vec3( texCoord.x, texCoord.y, texture( depthMap, texCoord).r ) - vec3( 1.0 ), 1.0 );
    worldSpacePosition = inverseViewProjection * worldSpacePosition;
    worldSpacePosition /= worldSpacePosition.w;

    vec3 position = worldSpacePosition.xyz;

    vec3 worldSpaceNormal = normalize( 2.0 * texture( normalMap, texCoord ).rgb - vec3( 1.0 ) );
#endif

    vec3 diffuseColor = litMaterialData[ materialID ].diffuseColor;
    vec3 specularColor = litMaterialData[ materialID ].specularColor;
    vec3 emissiveColor = litMaterialData[ materialID ].emissiveColor;
    float shininess = max( litMaterialData[ materialID ].shininess, 0.001 );

    vec3 pointToView = viewPosition - position;
    float pointToViewDistance = length( viewPosition - position );
    vec3 pointToViewDirection = pointToView / pointToViewDistance;

    vec3 diffuseIntensity = vec3( 0.0 );
    vec3 specularIntensity = vec3( 0.0 );

    for( int i = 0; i < directionalLightCount; ++i )
    {            
        float cascade = 0;
        cascade += step( directionalLightData[ i ].shadowRange[ 0 ], pointToViewDistance );
        cascade += step( directionalLightData[ i ].shadowRange[ 1 ], pointToViewDistance );
        cascade += step( directionalLightData[ i ].shadowRange[ 2 ], pointToViewDistance );

        vec4 shadowMapPosition = directionalLightData[ i ].shadowViewProjection[ int( cascade ) ] * vec4( position, 1.0 );
        shadowMapPosition /= shadowMapPosition.w;
        shadowMapPosition.xyz = shadowMapPosition.xyz * 0.5 + vec3( 0.5, 0.5, 0.5 );

        float lightFactor = texture( shadowMap, vec4( shadowMapPosition.xy, cascade, shadowMapPosition.z - directionalLightData[ i ].bias ) );
        
        float surfaceExposure = max( dot( -normalize( directionalLightData[ i ].direction ), worldSpaceNormal ), 0.0 );
        diffuseIntensity += lightFactor * directionalLightData[ i ].intensity * surfaceExposure * directionalLightData[ i ].color;

        vec3 halfVector = normalize( -directionalLightData[ i ].direction + pointToViewDirection );
        float surfaceHighlight = pow( max( dot( halfVector, worldSpaceNormal ), 0.0 ), shininess );
        float highlightIntensity = texture( specularMap, texCoord ).r;
        specularIntensity += lightFactor * directionalLightData[ i ].intensity * surfaceHighlight * highlightIntensity * directionalLightData[ i ].color;
    }

    for( int i = 0; i < pointLightCount; ++i )
    {
        vec3 positionToLight = pointLightData[ i ].position - position;
        float minSquareDist = pointLightData[ i ].falloffMinDistance * pointLightData[ i ].falloffMinDistance;
        float maxSquareDist = pointLightData[ i ].falloffMaxDistance * pointLightData[ i ].falloffMaxDistance;
        float squareDist = dot( positionToLight, positionToLight );
        float attenuation = ( 1.0 - smoothstep( minSquareDist, maxSquareDist, squareDist ) );
        float lightIntensity = pointLightData[ i ].intensity * attenuation;

        vec3 pointToLightDirection = normalize( pointLightData[ i ].position - position );
        float surfaceExposure = max( dot( pointToLightDirection, worldSpaceNormal ), 0.0 );
        diffuseIntensity += lightIntensity * surfaceExposure * pointLightData[ i ].color;

        vec3 halfVector = normalize( pointToLightDirection + pointToViewDirection );
        float surfaceHighlight = pow( max( dot( halfVector, worldSpaceNormal ), 0.0 ), shininess );
        float highlightIntensity = texture( specularMap, texCoord ).r;
        specularIntensity += lightIntensity * surfaceHighlight * highlightIntensity * pointLightData[ i ].color;
    }

    for( int i = 0; i < spotLightCount; ++i )
    {
        vec3 positionToLight = spotLightData[ i ].position - position;
        float minSquareDist = spotLightData[ i ].falloffMinDistance * spotLightData[ i ].falloffMinDistance;
        float maxSquareDist = spotLightData[ i ].falloffMaxDistance * spotLightData[ i ].falloffMaxDistance;
        float squareDist = dot( positionToLight, positionToLight );
        float attenuation = ( 1.0 - smoothstep( minSquareDist, maxSquareDist, squareDist ) );
        float lightIntensity = spotLightData[ i ].intensity * attenuation;

        vec3 pointToLightDirection = normalize( spotLightData[ i ].position - position );
        float spotExposure = clamp( ( dot( pointToLightDirection, -normalize( spotLightData[ i ].direction ) ) - spotLightData[ i ].outerRange ) / spotLightData[ i ].innerRange, 0.0, 1.0 );
        float surfaceExposure = max( dot( pointToLightDirection, worldSpaceNormal ), 0.0 ) * spotExposure;
        diffuseIntensity += lightIntensity * surfaceExposure * spotLightData[ i ].color;

        vec3 halfVector = normalize( pointToLightDirection + pointToViewDirection );
        float surfaceHighlight = pow( max( dot( halfVector, worldSpaceNormal ), 0.0 ), shininess ) * spotExposure;
        float highlightIntensity = texture( specularMap, texCoord ).r;
        specularIntensity += lightIntensity * surfaceHighlight * highlightIntensity * spotLightData[ i ].color;
    }
    
    vec3 color = clamp( diffuseIntensity * diffuseColor * diffuseTextureColor.rgb + specularIntensity * specularColor * diffuseTextureColor.rgb, 0.0, 1.0 );
    vec3 emissive = texture( emissiveMap, texCoord ).rgb * emissiveColor * ( 0.5 + 0.5 * dot( pointToViewDirection, worldSpaceNormal ) );
    finalColor = vec4( color + emissive, 1.0 );
    finalEmissive = vec4( emissive, 1.0 );
}